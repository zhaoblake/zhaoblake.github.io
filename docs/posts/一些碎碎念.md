---
draft: false 
date: 2024-03-31 
categories:
  - Python
  - 碎碎念
comments: true
authors: [Blake]
---

# 一些碎碎念

我经常会看同事的代码，倒不是什么怪癖（想到之前看到的段子：代码是程序员的隐私，就像内裤，我承认有漏洞，不给你看到就行...😥），一方面的是工作需要，维护别人的代码在我司是个高频的场景。另一方面，就是满足我个人的私欲了：我时不时能在同事的代码里，发现一些很巧妙的写法，每每这时，心中暗自窃喜：又学到了！当然，也会发现一些比较奇怪的写法 🤦‍♂️。

<!-- more -->

## 直接调用魔法方法



> The first thing to know about special methods is that they are meant to be called by the Python interpreter, and not by you. 
> 
>                                                                                    Luciano Ramalho, ***Fluent Python***



魔法方法，官方叫特殊方法（special methods），以双下划线开头双下线结尾的方法，常见的有 `__init__`、`__new__` 等。

对于 Python 内置的一些容器类型，字典，列表等，我们可以 `len` 方法来获取它的长度，也就是元素个数。如果我们自己实现了一个容器类型 ，也想让它支持通过 `len` 方法来获取它的长度，我们要怎么做呢？

我们先借助 `list` 来实现一个队列（仅作为演示使用，勿用于生产）。

```python
class Full(Exception):
    pass


class Empty(Exception):
    pass


class Queue:

    def __init(self, maxsize):
        self.maxsize = maxsize
        self._data = list()


def push(self, item):
    if len(self._data) == self.maxsize:
        raise Full
    self._data.append(item)


def get(self):
    if not self._data:
        raise Empty
    return self._data.pop(0)
```

测试这个队列能不能工作。

```shell
>>> q = Queue(3)
>>> q.push(1)
>>> q.push(2)
>>> q.push(3)
>>> q.get()
1
>>> q.get()
2
>>> q.get()
3
>>> q.get()
Traceback (most recent call last):
...
__main__.Empty
```

回到刚刚那个需求，我们也想让它支持通过 `len`  方法来获取它的长度，要怎么做呢？

可以通过定一个 `__len__` 魔法方法来实现。

```python
def __len__(self):
  return len(self._data)
```

```shell
>>> q = Queue(3)  
>>> q.push(1)
>>> q.push(2)
>>> q.push(3)
>>> len(q)
3
```

**定义的魔法方法目的，是让它支持 Python 的一些语法机制**。我们给自定义的类型定义了 `__len__` 方法，目的是为了让它支持通过 `len` 方法获取长度，而不是说我们要自己调用 `__len__` 方法。

这时候，可能会有小伙伴会问，直接调用魔法方法是不是更快？提问环节🙋‍

来，做个简单的 benchmark。

```python
q = Queue(1000)
start = time.perf_counter()
for _ in range(10000):
    len(q)
end = time.perf_counter()
print(f"len: {end - start}")  

start = time.perf_counter()
for _ in range(10000):
    q.__len__()
end = time.perf_counter()
print(f"__len__: {end - start}")
```

结果如下 👇

```
len: 0.002637699999999993
__len__: 0.0023554999999999965
```

确实，直接调用魔法方法的确更快。这很好理解，因为 `len(q)`  时，Python 最终调用的还是 `q.__len__`，而直接调用 `__len__` 没有了中间商赚差价。

但**性能优化第一步先是找到程序的性能瓶颈，再针对瓶颈进行优化**。所以，这里真的是你程序的性能瓶颈吗🤔？



## 忽略异常不做任何处理

> Errors should never pass silently.
> 
>                                                                                         Tim Peters, ***The Zen of Python***



我见过很多，自己也写过类似下面的代码：捕获异常，然后忽略掉不做任何处理。

这是一种极其危险的写法，这里的异常可能会产生连锁反应，造成后续的各种奇奇怪怪的 bug。由于异常并没法被记录下来，无疑给后续的回溯排查增加难度。如果这个 bug 还不能稳定复现，直接升天😵...

```python
try:
    ...
except:  # bad
    pass


try:
    ...
except Exception:  # bad
    pass
```

至少，打个日志记录下。日志等级推荐使用 `ERROR` 来标明这里出现了异常。

```python
try:
  ...
except Exception as e:  # at very least, log it
  logger.error(e)
```

## 无用代码只注释不删除

> Once code isn’t used any more, we should delete it. I don’t worry that I may
> need it sometime in the future; should that happen, I have my version control
> system so I can always dig it out again. If it’s something I really think I may need
> one day, I might put a comment into the code that mentions the lost code and
> which revision it was removed in—but, honestly, I can’t remember the last time
> I did that, or regretted that I hadn’t done it.
> 
>                                                                                               Martin Fowler, ***Refactoring***



这段代码已经废弃了，是注释还是删除？提问环节🙋‍

我在某次的内部分享上问了上面的问题，得到一个么棱两可的回答：”看情况“。在我看来这个问题并没有什么可么棱两可的空间：直接删了就行。**遗留的无用代码（即使被注释掉），只会白白增加代码的复杂度，增加阅读者的心智成本**。

可能会有同学会问，万一这段代码我后面还会用怎么办？

会不会出现这种情况？确实会，但是非常少。至少在我的工作经历中，代码被删了，后面又用到的这种情况基本没有。不必为了这种极少发生的情况，把不用的代码留下来。况且，由于版本控制系统的存在，这些代码的改动会被记录下来，你删了，还能通过版本控制系统找回来。

## 不恰当地使用反射

> It’s very tempting to use these “cool” features when they’re not absolutely necessary. It’s harder to read, understand, and debug code that’s using unusual features underneath. 
> 
>                                                                                               ***Google Python Style Guide***



Python 中有很多方法利用了反射机制，例如：`type`，`isinstance`，`callable`，`gettarr` 等，今天先只欺负 `getattr` 它一个，先简单演示下 `getattr` 的用法。

```python
class Person:

    def __init__(self, name, gendr):
        self.name = name
        self.gender = gender

    @staticmethod
    def eat(food):
        print(f"eating {food}...")


>>> p = Person("Blake", "male")
>>> getattr(p, "name")
Blake
>>> getattr(p, "eat")(meat)
eating meat...
```

简单来说，就是通过字符，来获取对象的属性或方法。

正如谷歌 Python 代码风格指南中所述，**业务代码中尽量避免使用 `gettattr` 或诸如此类的 powerful features，你要清楚的了解到使用其所带来的成本：代码复杂性变高、可读性下降、调试困难...**

这就是沙漠里面的一瓶尿，不到万不得已，不要喝。

## 参考资料

- [Fluent Python: Clear, Concise, and Effective Programming](https://book.douban.com/subject/27028517/)

- [Refactoring: Improving the Design of Existing Code](https://book.douban.com/subject/30468597/)

- [PEP 20 – The Zen of Python | peps.python.org](https://peps.python.org/pep-0020/)

- [Avoiding Silent Failures in Python: Best Practices for Error Handling](https://pybit.es/articles/python-errors-should-not-pass-silently/)

- [Google Python Style Guide](https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/)