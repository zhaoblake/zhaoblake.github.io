---
draft: true 
date: 2024-04-08
categories:
  - Python
comments: true
authors: [Blake]
---
这是去年年底就发生的事情了，至于为啥现在拿出来说，是因为我在浏览仓库的的提交记录时，一个直白、残酷的 commit message 再一次地扎进我的眼里😵：还原 xxx（我的名字）提交错误。这是我同事提交的 commit，用于回退我之前提交的部分代码。就是这部分代码，导致了这次线上事故...

<!-- more -->
## 背景

我们收到了为某个任务执行提速的需求：并发执行。我们的任务执行引擎是支持协程异步执行的，但是这个任务的业务代码是同步的。有两种方案摆在面前：1. 将任务代码改成异步；2. 引擎新增一个 runner，支持多线程执行任务。 
鉴于时间较为紧张，修改任务代码的工作量和风险要远大新增一个多线程执行的 runner，我们最终选择的第二个方案，这个任务也被我给接下了。

## 开发

新加一个线程 runner 并不复杂，再加上一些锁的处理，半天时间就开发完毕，提交上线了。

## 事故

当天下班后，我在回家的地铁上，接到同事的电话：我提交的代码有问题，线上炸了！！！

我第一反应是不可能，我只是新增了一个线程 runner 函数，这是一个增量开发，还没有任何业务的任务切换到这个 runner 执行。

最后同事排查结果是：我删除了一些“无用”的导入（import）。


## `__init__subclass__`

`__init__subclass` 是一个特殊方法（special method），定义在父类中，当子类被创建时，它会被自动调用。

```python
class BaseClass:
    
    def __init_subclass__(cls, **kwargs):
        print("A subclass of BaseClass is being created")

        
class SubClass(BaseClass):
    pass
```

上面的例子中，当子类 `SubClass` **被创建时**，就会触发 `BaseClass` 的 `__init__subclass__` 方法。
利用这个特性，我们可以完成一些注册操作。

```python
# listener.py
listeners = set()


class Listener: 
    
    def __init_subclass__(cls, **kwargs):
        listeners.add(cls)
        
    def run(self):
        raise NotImplemented
  

class AListener(Listener):
    
    def run(self):
        print("Listener A is running")


class BListener(Listener):
    
    def run(self):
        print("Listener A is running")
```

```shell
>>> from listener import listeners
>>> listeners
{<class 'listener.AListener'>, <class 'listener.BListener'>}
```

结果符合我们的预期，一切都是如此的平静且美好🙏。

当 listener 数量变多时，listener.py 文件中存放了各种类型的 listener 而变得混乱，我们把不同类型的 listener 放到不同的文件中。

```python
# listener.py
listeners = set()


class Listener: 
    
    def __init_subclass__(cls, **kwargs):
        listeners.add(cls)
        
    def run(self):
        raise NotImplemented
```
```python
# a_listener.py
from listener import Listener

class A1Listener(Listener):
    
    def run(self):
        print("Listener A1 is running")
        

class A2Listener(Listener):
    
    def run(self):
        print("Listener A2 is running")
        
...
```
```python
# b_listener.py
from listener import Listener

class B1Listener(Listener):
    
    def run(self):
        print("Listener B1 is running")
        

class B2Listener(Listener):
    
    def run(self):
        print("Listener B2 is running")
        
...
```
于是...

```shell
>>> from listener import listeners
>>> listeners
set()
```
WTF? 😱

定义在 a_listener.py 和 b_listener.py 中的 listener 没有被直接使用（导入）过，对于 Python 解释器来说，它们都是不可见的，因此解释器也会不去创建这些 listener ，因此也不会触发父类的 `__init__subclass__` 进行注册。

```shell
>>> import a_listener
>>> import b_listener
>>> from listener import listeners
>>> listeners
{<class 'a_listener.A2Listener'>, <class 'b_listener.B2Listener'>, <class 'a_listener.A1Listener'>, <class 'b_listener.B1Listener'>}
```
在我们导入后，Python 解释器会执行被导入文件中的代码，创建对应的 listener, 触发父类的 `__init__subclass__` 进行注册。 

似乎一切又平静且美好了？

## 原因
导入了这些文件，但是并没有直接使用，任何现代的 IDE 都会在这里向你发出类似 “unused import statement” 的警告，虽然程序可以正常执行。
一同协作的同事，并不明白这些“无用”导入的意图（特别是代码中没有进行任何说明），可能会顺手删除掉。 如果 IDE 会配置了 linter，这些未被使用的导入也会被自动格式化掉。
这就是这次事故的原因，我删除了一些“无用”的导入（import），但实际上这些导入极其隐式地辅助完成了一些注册操作。


## 优化

```python
def register_listeners():
    import a_listener
    import b_listener

...

# 程序入口处显式调用
register_listeners()
```


## 教训

- 不要乱动别人代码，即使是格式化
- 不要利用导入（import）来隐式地实现某些逻辑


